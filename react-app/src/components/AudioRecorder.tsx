import React, { useState, useRef, useEffect, useCallback } from 'react';

interface AudioRecorderProps {
  onRecordingComplete: (audioBlob: Blob) => void;
  isRecording: boolean;
  onRecordingStart: () => void;
  onRecordingStop: () => void;
  continuousMode?: boolean;
}

interface SpeechRecognition extends EventTarget {
  continuous: boolean;
  interimResults: boolean;
  lang: string;
  start(): void;
  stop(): void;
  abort(): void;
  onresult: ((event: any) => void) | null;
  onerror: ((event: any) => void) | null;
  onstart: (() => void) | null;
  onend: (() => void) | null;
}

declare global {
  interface Window {
    SpeechRecognition: new () => SpeechRecognition;
    webkitSpeechRecognition: new () => SpeechRecognition;
  }
}

const AudioRecorder: React.FC<AudioRecorderProps> = ({
  onRecordingComplete,
  isRecording,
  onRecordingStart,
  onRecordingStop,
  continuousMode = false
}) => {
  const [isListening, setIsListening] = useState(false);
  const [transcript, setTranscript] = useState('');
  const [duration, setDuration] = useState(0);
  const [audioLevels, setAudioLevels] = useState<number[]>(Array(30).fill(0));
  const [micAccess, setMicAccess] = useState<'granted' | 'denied' | 'pending'>('pending');
  const [debugInfo, setDebugInfo] = useState<string>('ÏãúÏä§ÌÖú ÌôïÏù∏ Ï§ë...');
  const [availableDevices, setAvailableDevices] = useState<MediaDeviceInfo[]>([]);
  const [selectedDeviceId, setSelectedDeviceId] = useState<string>('');

  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const speechRecognitionRef = useRef<SpeechRecognition | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const analyserRef = useRef<AnalyserNode | null>(null);
  const animationRef = useRef<number | undefined>(undefined);
  const timerRef = useRef<NodeJS.Timeout | undefined>(undefined);

  // Í∞úÏÑ†Îêú ÌååÌòï ÏãúÍ∞ÅÌôî
  const updateAudioLevels = useCallback(() => {
    if (!analyserRef.current) return;

    const bufferLength = 512;
    const dataArray = new Uint8Array(bufferLength);
    analyserRef.current.getByteFrequencyData(dataArray);

    const newLevels = Array(30).fill(0).map((_, i) => {
      const start = Math.floor((i * bufferLength) / 30);
      const end = Math.floor(((i + 1) * bufferLength) / 30);
      const slice = dataArray.slice(start, end);
      const average = slice.reduce((sum, value) => sum + value, 0) / slice.length;
      
      const normalized = Math.min(100, (average / 128) * 100);
      return normalized > 5 ? normalized * (1 + Math.random() * 0.3) : normalized;
    });

    setAudioLevels(newLevels);
    animationRef.current = requestAnimationFrame(updateAudioLevels);
  }, []);

  // ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎßàÏù¥ÌÅ¨ Ïû•Ïπò Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  const getAvailableDevices = useCallback(async () => {
    try {
      console.log('üé§ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎßàÏù¥ÌÅ¨ Ïû•Ïπò Í≤ÄÏÉâ...');
      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioInputs = devices.filter(device => device.kind === 'audioinput');
      
      console.log('üé§ Î∞úÍ≤¨Îêú ÎßàÏù¥ÌÅ¨ Ïû•ÏπòÎì§:');
      audioInputs.forEach((device, index) => {
        console.log(`  ${index + 1}. ${device.label || `ÎßàÏù¥ÌÅ¨ ${index + 1}`} (ID: ${device.deviceId})`);
      });
      
      setAvailableDevices(audioInputs);
      
      // Í∏∞Î≥∏ Ïû•Ïπò ÏÑ†ÌÉù
      if (audioInputs.length > 0 && !selectedDeviceId) {
        setSelectedDeviceId(audioInputs[0].deviceId);
        setDebugInfo(`Í∏∞Î≥∏ ÎßàÏù¥ÌÅ¨: ${audioInputs[0].label || 'ÎßàÏù¥ÌÅ¨ 1'}`);
      }
      
      return audioInputs;
    } catch (error) {
      console.error('‚ùå Ïû•Ïπò Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
      setDebugInfo('ÎßàÏù¥ÌÅ¨ Ïû•Ïπò Î™©Î°ùÏùÑ Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§');
      return [];
    }
  }, [selectedDeviceId]);

  // Í∂åÌïú ÌôïÏù∏ (Í∞úÏÑ†Îê®)
  const checkPermission = useCallback(async () => {
    console.log('üé§ ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌôïÏù∏ ÏãúÏûë...');
    setDebugInfo('ÎßàÏù¥ÌÅ¨ Í∂åÌïú ÌôïÏù∏ Ï§ë...');
    
    try {
      if (navigator.permissions) {
        try {
          const result = await navigator.permissions.query({ name: 'microphone' as PermissionName });
          console.log('üìã Í∂åÌïú ÏÉÅÌÉú:', result.state);
          setDebugInfo(`Í∂åÌïú ÏÉÅÌÉú: ${result.state}`);
          
          if (result.state === 'denied') {
            setMicAccess('denied');
            setDebugInfo('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§.');
            return false;
          }
        } catch (e) {
          console.log('‚ö†Ô∏è Í∂åÌïú API ÏÇ¨Ïö© Î∂àÍ∞Ä');
        }
      }

      setDebugInfo('ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑º ÌÖåÏä§Ìä∏ Ï§ë...');
      
      // Î®ºÏ†Ä Í∏∞Î≥∏ ÎßàÏù¥ÌÅ¨Î°ú ÌÖåÏä§Ìä∏
      const stream = await navigator.mediaDevices.getUserMedia({ 
        audio: { 
          echoCancellation: true, 
          noiseSuppression: true,
          autoGainControl: true
        } 
      });
      
      console.log('‚úÖ ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑º ÏÑ±Í≥µ');
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length > 0) {
        const track = audioTracks[0];
        console.log('üé§ ÌòÑÏû¨ ÏÇ¨Ïö© Ï§ëÏù∏ ÎßàÏù¥ÌÅ¨:', track.label);
        setDebugInfo(`ÌòÑÏû¨ ÎßàÏù¥ÌÅ¨: ${track.label || 'Í∏∞Î≥∏ ÎßàÏù¥ÌÅ¨'}`);
      }
      
      stream.getTracks().forEach(track => track.stop());
      
      // Í∂åÌïú ÌöçÎìù ÌõÑ ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ïû•Ïπò Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
      await getAvailableDevices();
      
      setMicAccess('granted');
      return true;
    } catch (error: any) {
      console.error('‚ùå ÎßàÏù¥ÌÅ¨ Ï†ëÍ∑º Ïã§Ìå®:', error);
      setMicAccess('denied');
      
      if (error.name === 'NotAllowedError') {
        setDebugInfo('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§.');
      } else if (error.name === 'NotFoundError') {
        setDebugInfo('ÎßàÏù¥ÌÅ¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
      } else {
        setDebugInfo(`ÎßàÏù¥ÌÅ¨ Ïò§Î•ò: ${error.message}`);
      }
      return false;
    }
  }, [getAvailableDevices]);

  // ÏùåÏÑ± Ïù∏Ïãù Ï¥àÍ∏∞Ìôî
  const initSpeechRecognition = useCallback(() => {
    console.log('üéôÔ∏è ÏùåÏÑ± Ïù∏Ïãù Ï¥àÍ∏∞Ìôî...');
    
    const SpeechRecognition = window.webkitSpeechRecognition || window.SpeechRecognition;
    if (!SpeechRecognition) {
      console.error('‚ùå Web Speech API ÏßÄÏõê ÏïàÎê®');
      setDebugInfo('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏùåÏÑ± Ïù∏ÏãùÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
      return null;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true;
    recognition.interimResults = true;
    recognition.lang = 'ko-KR';

    recognition.onstart = () => {
      console.log('üé§ ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûëÎê®');
      setDebugInfo('ÏùåÏÑ± Ïù∏ÏãùÏù¥ ÌôúÏÑ±ÌôîÎêòÏóàÏäµÎãàÎã§');
    };

    recognition.onresult = (event) => {
      let finalTranscript = '';
      let interimTranscript = '';
      
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const result = event.results[i];
        if (result.isFinal) {
          finalTranscript += result[0].transcript;
        } else {
          interimTranscript += result[0].transcript;
        }
      }

      const allText = finalTranscript + interimTranscript;
      setTranscript(allText);
      
      if (allText) {
        setDebugInfo(`ÏùåÏÑ± Ïù∏Ïãù Ï§ë: "${allText.slice(0, 30)}..."`);
      }

      // ÌôïÏû•Îêú Ï¢ÖÎ£å ÌÇ§ÏõåÎìú
      const endKeywords = [
        'Ïù¥ÏÉÅÏûÖÎãàÎã§', 'ÎÅùÏûÖÎãàÎã§', 'ÎßàÏπ©ÎãàÎã§', 'Í∞êÏÇ¨Ìï©ÎãàÎã§', 'ÏôÑÎ£åÏûÖÎãàÎã§', 'Îã§ÌñàÏäµÎãàÎã§',
        'Ïù¥ÏÉÅÏù¥ÏóêÏöî', 'ÎÅùÏù¥ÏóêÏöî', 'Ïù¥ÏÉÅ', 'ÎÅù', 'ÏôÑÎ£å', 'ÎßàÏπ®', 'ÎãµÎ≥ÄÎÅù', 'ÎãµÎ≥Ä ÎÅù',
        'Í∑∏Îßå', 'Ïó¨Í∏∞ÍπåÏßÄ', 'Îã§Ïùå', 'ÎÑòÏñ¥Í∞Ä', 'Ïù¥Îßå'
      ];

      if (finalTranscript && endKeywords.some(keyword => allText.includes(keyword))) {
        console.log('üéØ Ï¢ÖÎ£å ÌÇ§ÏõåÎìú Í∞êÏßÄ:', allText);
        setDebugInfo('Ï¢ÖÎ£å ÌÇ§ÏõåÎìú Í∞êÏßÄÎê® - ÎÖπÏùå Ï§ëÏßÄ');
        setTimeout(stopRecording, 500);
      }
    };

    recognition.onerror = (event) => {
      console.error('üé§ ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò:', event.error);
      
      if (event.error === 'no-speech') {
        console.log('üîá ÏùåÏÑ±Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§');
        setDebugInfo('ÏùåÏÑ±Ïù¥ Í∞êÏßÄÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Îã§Ïãú ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî.');
        // no-speechÎäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏúºÎØÄÎ°ú ÎÖπÏùå Ï§ëÏßÄÌïòÏßÄ ÏïäÏùå
        return;
      } else if (event.error === 'audio-capture') {
        setDebugInfo('ÎßàÏù¥ÌÅ¨ Ïò§ÎîîÏò§ Ï∫°Ï≤ò Ïã§Ìå®');
        setMicAccess('denied');
      } else if (event.error === 'not-allowed') {
        setMicAccess('denied');
        setDebugInfo('ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ Í±∞Î∂ÄÎêòÏóàÏäµÎãàÎã§');
      } else if (event.error === 'network') {
        setDebugInfo('ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÎ°ú ÏùåÏÑ± Ïù∏Ïãù Ïã§Ìå®');
      } else if (event.error === 'aborted') {
        console.log('üõë ÏùåÏÑ± Ïù∏ÏãùÏù¥ Ï§ëÎã®ÎêòÏóàÏäµÎãàÎã§');
        return; // Ï†ïÏÉÅÏ†ÅÏù∏ Ï§ëÎã®
      } else {
        setDebugInfo(`ÏùåÏÑ± Ïù∏Ïãù Ïò§Î•ò: ${event.error}`);
      }
    };

    recognition.onend = () => {
      console.log('üé§ ÏùåÏÑ± Ïù∏Ïãù Ï¢ÖÎ£åÎê®');
      if (isListening && continuousMode) {
        console.log('üîÑ Ïó∞ÏÜç Î™®Îìú - ÏùåÏÑ± Ïù∏Ïãù Ïû¨ÏãúÏûë');
        setTimeout(() => {
          if (speechRecognitionRef.current && isListening) {
            try {
              console.log('üîÑ ÏùåÏÑ± Ïù∏Ïãù Ïû¨ÏãúÏûë ÏãúÎèÑ...');
              speechRecognitionRef.current.start();
              setDebugInfo('ÏùåÏÑ± Ïù∏Ïãù Ïû¨ÏãúÏûëÎê®');
            } catch (error: any) {
              console.warn('ÏùåÏÑ± Ïù∏Ïãù Ïû¨ÏãúÏûë Ïã§Ìå®:', error);
              if (error.name === 'InvalidStateError') {
                console.log('üîÑ Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù¥Í±∞ÎÇò ÏãúÏûëÌï† Ïàò ÏóÜÎäî ÏÉÅÌÉú');
                setDebugInfo('ÏùåÏÑ± Ïù∏Ïãù ÏÉÅÌÉú Ïò§Î•ò - Ïû¨ÏãúÎèÑ Ï§ë...');
                // Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑ
                setTimeout(() => {
                  if (speechRecognitionRef.current && isListening) {
                    try {
                      speechRecognitionRef.current.start();
                    } catch (e) {
                      console.warn('Ïû¨ÏãúÎèÑÎèÑ Ïã§Ìå®:', e);
                    }
                  }
                }, 1000);
              }
            }
          }
        }, 500); // 500ms ÌõÑ Ïû¨ÏãúÏûë (Îçî ÏïàÏ†ïÏ†Å)
      }
    };

    return recognition;
  }, [isListening, continuousMode]);

  // ÎÖπÏùå ÏãúÏûë
  const startRecording = useCallback(async () => {
    console.log('üé¨ ÎÖπÏùå ÏãúÏûë ÏöîÏ≤≠');
    setDebugInfo('ÎÖπÏùå Ï§ÄÎπÑ Ï§ë...');
    
    if (!await checkPermission()) {
      console.error('‚ùå Í∂åÌïú ÌôïÏù∏ Ïã§Ìå®');
      return;
    }

    try {
      const constraints = {
        audio: selectedDeviceId ? {
          deviceId: { exact: selectedDeviceId },
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 44100
        } : {
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: true,
          sampleRate: 44100
        }
      };
      
      console.log('üé§ ÏÑ†ÌÉùÎêú ÎßàÏù¥ÌÅ¨Î°ú Ïä§Ìä∏Î¶º ÏöîÏ≤≠:', selectedDeviceId);
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      streamRef.current = stream;

      // Ïã§Ï†ú ÏÇ¨Ïö© Ï§ëÏù∏ Ïû•Ïπò ÌôïÏù∏
      const audioTracks = stream.getAudioTracks();
      if (audioTracks.length > 0) {
        const track = audioTracks[0];
        console.log('üé§ Ïã§Ï†ú ÏÇ¨Ïö© Ï§ëÏù∏ ÎßàÏù¥ÌÅ¨:', track.label);
        setDebugInfo(`ÏÇ¨Ïö© Ï§ë: ${track.label || 'ÎßàÏù¥ÌÅ¨'}`);
      }

      // Ïò§ÎîîÏò§ Î∂ÑÏÑùÍ∏∞ ÏÑ§Ï†ï
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      const analyser = audioContext.createAnalyser();
      const source = audioContext.createMediaStreamSource(stream);
      
      analyser.fftSize = 1024;
      analyser.smoothingTimeConstant = 0.3;
      source.connect(analyser);
      analyserRef.current = analyser;

      // MediaRecorder ÏÑ§Ï†ï
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;
      audioChunksRef.current = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          audioChunksRef.current.push(e.data);
        }
      };

      mediaRecorder.onstop = () => {
        console.log('üé¨ MediaRecorder Ï§ëÏßÄÎê®');
        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/wav' });
        onRecordingComplete(audioBlob);
      };

      // ÏùåÏÑ± Ïù∏Ïãù ÏãúÏûë
      const recognition = initSpeechRecognition();
      if (recognition) {
        speechRecognitionRef.current = recognition;
        recognition.start();
      }

      mediaRecorder.start(500);
      updateAudioLevels();
      
      setIsListening(true);
      setDuration(0);
      setTranscript('');
      setDebugInfo('ÎÖπÏùå Ï§ë...');
      onRecordingStart();

      // ÌÉÄÏù¥Î®∏ ÏãúÏûë
      timerRef.current = setInterval(() => setDuration(prev => prev + 1), 1000);

    } catch (error: any) {
      console.error('‚ùå ÎÖπÏùå ÏãúÏûë Ïã§Ìå®:', error);
      setDebugInfo(`ÎÖπÏùå ÏãúÏûë Ïã§Ìå®: ${error.message}`);
      setMicAccess('denied');
    }
  }, [checkPermission, initSpeechRecognition, onRecordingComplete, onRecordingStart, updateAudioLevels]);

  // ÎÖπÏùå Ï§ëÏßÄ
  const stopRecording = useCallback(() => {
    console.log('‚èπÔ∏è ÎÖπÏùå Ï§ëÏßÄ ÏöîÏ≤≠');
    
    if (animationRef.current) {
      cancelAnimationFrame(animationRef.current);
      animationRef.current = undefined;
    }
    if (timerRef.current) {
      clearInterval(timerRef.current);
      timerRef.current = undefined;
    }
    
    if (speechRecognitionRef.current) {
      speechRecognitionRef.current.abort();
      speechRecognitionRef.current = null;
    }
    
    if (mediaRecorderRef.current && mediaRecorderRef.current.state === 'recording') {
      mediaRecorderRef.current.stop();
    }
    
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track: MediaStreamTrack) => {
        track.stop();
      });
      streamRef.current = null;
    }
    
    setIsListening(false);
    setAudioLevels(Array(30).fill(0));
    setDebugInfo('ÎÖπÏùå Ï§ëÏßÄÎê®');
    onRecordingStop();
  }, [onRecordingStop]);

  // ÏûêÎèô ÏãúÏûë/Ï§ëÏßÄ Í¥ÄÎ¶¨
  useEffect(() => {
    if (continuousMode && isRecording && !isListening && micAccess === 'granted') {
      const timer = setTimeout(startRecording, 1000);
      return () => clearTimeout(timer);
    } else if (!isRecording && isListening) {
      stopRecording();
    }
  }, [continuousMode, isRecording, isListening, micAccess, startRecording, stopRecording]);

  useEffect(() => {
    checkPermission();
    return () => { 
      if (isListening) stopRecording(); 
    };
  }, [checkPermission, isListening, stopRecording]);

  const formatTime = (seconds: number) => `${Math.floor(seconds / 60)}:${(seconds % 60).toString().padStart(2, '0')}`;

  // Í∞úÏÑ†Îêú ÌååÌòï Ïª¥Ìè¨ÎÑåÌä∏
  const WaveForm = () => (
    <div style={{ 
      display: 'flex', 
      alignItems: 'end', 
      justifyContent: 'center',
      gap: '2px', 
      height: '60px',
      marginBottom: '15px',
      padding: '0 20px'
    }}>
      {audioLevels.map((level, i) => (
        <div
          key={i}
          style={{
            width: '4px',
            height: `${Math.max(3, (level / 100) * 60)}px`,
            background: level > 15 
              ? `linear-gradient(to top, #4caf50 0%, #8bc34a 50%, #cddc39 100%)` 
              : '#e0e0e0',
            borderRadius: '2px',
            transition: 'all 0.1s ease',
            animation: level > 15 ? `wave-${i % 3} 0.8s ease-in-out infinite alternate` : 'none',
            opacity: level > 5 ? 1 : 0.5
          }}
        />
      ))}
    </div>
  );

  if (micAccess === 'denied') {
    return (
      <div style={{ textAlign: 'center', padding: '25px', background: '#ffebee', borderRadius: '15px', maxWidth: '500px' }}>
        <div style={{ fontSize: '48px', marginBottom: '15px' }}>üé§‚ùå</div>
        <div style={{ color: '#d32f2f', fontWeight: 'bold', fontSize: '18px', marginBottom: '10px' }}>
          ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏù¥ ÌïÑÏöîÌï©ÎãàÎã§
        </div>
        <div style={{ fontSize: '14px', color: '#666', marginBottom: '15px', padding: '10px', background: '#f5f5f5', borderRadius: '8px' }}>
          <strong>ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥:</strong><br/>
          {debugInfo}
        </div>
        <div style={{ fontSize: '14px', color: '#666', marginBottom: '20px', lineHeight: '1.5' }}>
          1. Î∏åÎùºÏö∞Ï†Ä Ï£ºÏÜåÏ∞Ω ÏôºÏ™ΩÏùò üîí ÏïÑÏù¥ÏΩò ÌÅ¥Î¶≠<br/>
          2. ÎßàÏù¥ÌÅ¨ Í∂åÌïúÏùÑ "ÌóàÏö©"ÏúºÎ°ú Î≥ÄÍ≤Ω<br/>
          3. ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®<br/>
          <strong>Chrome Î∏åÎùºÏö∞Ï†Ä Í∂åÏû•</strong>
        </div>
        <button onClick={checkPermission} style={{ 
          padding: '12px 24px', background: '#2196f3', color: 'white', 
          border: 'none', borderRadius: '8px', cursor: 'pointer', marginRight: '10px'
        }}>
          Í∂åÌïú Îã§Ïãú ÌôïÏù∏
        </button>
        <button onClick={() => window.location.reload()} style={{ 
          padding: '12px 24px', background: '#4caf50', color: 'white', 
          border: 'none', borderRadius: '8px', cursor: 'pointer'
        }}>
          ÌéòÏù¥ÏßÄ ÏÉàÎ°úÍ≥†Ïπ®
        </button>
      </div>
    );
  }

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '20px' }}>
      {/* ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ ÌëúÏãú */}
      <div style={{ 
        fontSize: '12px', color: '#666', background: '#f8f9fa', 
        padding: '8px 12px', borderRadius: '8px', maxWidth: '400px', textAlign: 'center'
      }}>
        {debugInfo}
      </div>

      {/* ÎßàÏù¥ÌÅ¨ Ïû•Ïπò ÏÑ†ÌÉù */}
      {availableDevices.length > 1 && micAccess === 'granted' && !isListening && (
        <div style={{
          background: '#e3f2fd', padding: '15px', borderRadius: '12px', 
          border: '2px solid #2196f3', maxWidth: '400px', width: '100%'
        }}>
          <div style={{ fontSize: '14px', fontWeight: 'bold', marginBottom: '10px', color: '#1976d2' }}>
            üé§ ÎßàÏù¥ÌÅ¨ ÏÑ†ÌÉù ({availableDevices.length}Í∞ú Î∞úÍ≤¨)
          </div>
          <select
            value={selectedDeviceId}
            onChange={(e) => {
              setSelectedDeviceId(e.target.value);
              const selectedDevice = availableDevices.find(d => d.deviceId === e.target.value);
              setDebugInfo(`ÏÑ†ÌÉùÎê®: ${selectedDevice?.label || 'ÎßàÏù¥ÌÅ¨'}`);
            }}
            style={{
              width: '100%', padding: '8px', borderRadius: '6px', 
              border: '1px solid #2196f3', fontSize: '14px'
            }}
          >
            {availableDevices.map((device, index) => (
              <option key={device.deviceId} value={device.deviceId}>
                {device.label || `ÎßàÏù¥ÌÅ¨ ${index + 1}`}
              </option>
            ))}
          </select>
          <div style={{ fontSize: '12px', color: '#666', marginTop: '8px' }}>
            ÏõêÌïòÎäî ÎßàÏù¥ÌÅ¨Î•º ÏÑ†ÌÉùÌïú ÌõÑ ÎÖπÏùåÏùÑ ÏãúÏûëÌïòÏÑ∏Ïöî
          </div>
        </div>
      )}

      {/* ÏàòÎèô ÎÖπÏùå Î≤ÑÌäº */}
      {!continuousMode && (
        <button
          onClick={isListening ? stopRecording : startRecording}
          disabled={micAccess !== 'granted'}
          style={{
            width: '120px', height: '120px', borderRadius: '50%', border: 'none',
            background: isListening 
              ? 'linear-gradient(45deg, #ff6b6b, #ee5a24)' 
              : 'linear-gradient(45deg, #667eea, #764ba2)',
            color: 'white', fontSize: '16px', fontWeight: 'bold',
            cursor: micAccess === 'granted' ? 'pointer' : 'not-allowed',
            boxShadow: isListening 
              ? '0 8px 25px rgba(255, 107, 107, 0.4)' 
              : '0 8px 25px rgba(102, 126, 234, 0.4)',
            animation: isListening ? 'pulse 1.5s infinite' : 'none'
          }}
        >
          {isListening ? '‚èπÔ∏è\nÎÖπÏùå Ï§ëÏßÄ' : 'üé§\nÎÖπÏùå ÏãúÏûë'}
        </button>
      )}

      {/* ÎÖπÏùå Ï§ë ÏÉÅÌÉú */}
      {isListening && (
        <div style={{ 
          textAlign: 'center', padding: '25px', background: 'rgba(255,255,255,0.95)', 
          borderRadius: '20px', minWidth: '450px', boxShadow: '0 10px 30px rgba(0,0,0,0.15)',
          border: '3px solid #667eea' 
        }}>
          <div style={{ 
            color: '#ff6b6b', fontWeight: 'bold', marginBottom: '20px',
            display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '12px', fontSize: '18px' 
          }}>
            <div style={{ 
              width: '12px', height: '12px', background: '#ff6b6b', 
              borderRadius: '50%', animation: 'pulse 1s infinite' 
            }} />
            üé§ Ïã§ÏãúÍ∞Ñ ÏùåÏÑ± Ïù∏Ïãù
            <div style={{ 
              background: '#667eea', color: 'white', padding: '6px 15px', 
              borderRadius: '20px', fontSize: '16px' 
            }}>
              {formatTime(duration)}
            </div>
          </div>

          <WaveForm />

          <div style={{ 
            fontSize: '13px', marginBottom: '15px', fontWeight: 'bold',
            color: Math.max(...audioLevels) > 20 ? '#4caf50' : '#ff9800'
          }}>
            {Math.max(...audioLevels) > 20 ? 'üîä ÏùåÏÑ±Ïù¥ Ïûò Ïù∏ÏãùÎêòÍ≥† ÏûàÏäµÎãàÎã§' : 'üîá Îçî ÌÅ¨Í≥† Î™ÖÌôïÌïòÍ≤å ÎßêÌï¥Ï£ºÏÑ∏Ïöî'}
          </div>

          {transcript && (
            <div style={{ 
              fontSize: '16px', maxHeight: '100px', overflow: 'auto', padding: '15px',
              background: '#f8f9fa', borderRadius: '12px', marginBottom: '15px',
              border: '2px solid #e9ecef', lineHeight: '1.6' 
            }}>
              <div style={{ fontSize: '12px', color: '#666', marginBottom: '8px' }}>üí¨ Ïã§ÏãúÍ∞Ñ Ïù∏Ïãù:</div>
              <div>"{transcript}"</div>
            </div>
          )}

          <div style={{ 
            fontSize: '13px', color: '#28a745', background: '#e8f5e9',
            padding: '10px 15px', borderRadius: '20px' 
          }}>
            üí° <strong>"Ïù¥ÏÉÅ"</strong>, <strong>"ÎÅù"</strong>, <strong>"ÏôÑÎ£å"</strong> Îì±ÏùÑ ÎßêÌïòÎ©¥ ÏûêÎèôÏúºÎ°ú Îã§Ïùå ÏßàÎ¨∏ÏúºÎ°ú Ïù¥Îèô
            <br />
            <div style={{ fontSize: '12px', marginTop: '5px', color: '#666' }}>
              üé§ ÎßàÏù¥ÌÅ¨Í∞Ä ÏùåÏÑ±ÏùÑ Í∞êÏßÄÌïòÏßÄ Î™ªÌïòÎ©¥ Îçî ÌÅ¨Í≥† Î™ÖÌôïÌïòÍ≤å ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî
            </div>
          </div>
        </div>
      )}

      <style>{`
        @keyframes pulse {
          0%, 100% { transform: scale(1); opacity: 1; }
          50% { transform: scale(1.05); opacity: 0.8; }
        }
        @keyframes wave-0 {
          0% { transform: scaleY(1); }
          100% { transform: scaleY(1.5); }
        }
        @keyframes wave-1 {
          0% { transform: scaleY(1.2); }
          100% { transform: scaleY(1.8); }
        }
        @keyframes wave-2 {
          0% { transform: scaleY(0.8); }
          100% { transform: scaleY(1.3); }
        }
      `}</style>
    </div>
  );
};

export default AudioRecorder;